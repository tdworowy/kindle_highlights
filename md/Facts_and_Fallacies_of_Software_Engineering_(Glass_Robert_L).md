#### Facts and Fallacies of Software Engineering (Glass, Robert L.)
      The software industry is in the same state of affairs that the pharmaceutical industry was in during the late nineteenth century. Sometimes it seems that we have more snake-oil salespeople and doomsayers than sensible folks practicing and preaching in our midst.

      Fact 1 The most important factor in software work is not the tools and techniques used by the programmers, but rather the quality of the programmers themselves.

      The two causes of runaways that stand head and shoulders above all others are poor (usually optimistic) estimation and unstable requirements.

      For every 25 percent increase in problem complexity, there is a 100 percent increase in complexity of the software solution. That’s not a condition to try to change (even though reducing complexity is always a desirable thing to do); that’s just the way it is.

      What constituted an error of omitted logic? Such things as the failure to reset a data item to its original value after it had been used but was needed again and conditional statements with one or more conditions left out—the kinds of things that resulted from coders and designers not thinking sufficiently deeply about the problem they were addressing.

      Software that a typical programmer believes to be thoroughly tested has often had only about 55 to 60 percent of its logic paths executed. Using automated support, such as coverage analyzers, can raise that roughly to 85 to 90 percent. It is nearly impossible to test software at the level of 100 percent of its logic paths.

      Even if 100 percent test coverage were possible, that is not a sufficient criterion for testing. Roughly 35 percent of software defects emerge from missing logic paths, and another 40 percent from the execution of a unique combination of logic paths. They will not be caught by 100 percent coverage.

      Old hardware becomes obsolete; old software goes into production every night.

      The 60/60 rule: 60 percent of software’s dollar is spent on maintenance, and 60 percent of that maintenance is enhancement. Enhancing old software is, therefore, a big deal.

      “[T]he best way to prepare [to be a programmer] is to write programs and to study great programs that other people have written . . .. I went to the garbage cans at the Computer Science Center and I fished out listings of their operating systems.”

      Quality is an elusive term. And it is especially elusive in the software field. The elusiveness of the term is the primary focus of that wonderful book Zen and the Art of Motorcycle Maintenance (Pirsig 1974). The main character of the book, an academic looking into the real meaning of the word, went mad seeking a workable definition!

      The computer science field, which is stuck teaching writing programs before reading them, knowing that is wrong but doesn’t seem to know how to fix it.

      There are sure a lot of people in the software world who would like to believe that one size fits all. Those selling methodologies. Those defining process approaches. Those pushing tools and techniques. Those hoping to build component-based software. Those setting standards. Those doing research toward the next software engineering holy grail. Those academics who put the prefix meta- in front of whatever they’re working on. All of them are seeking that “universal software elixir.” Many of them even believe they have found it. All too many of them want to sell it to you!

      Reality is the murder of a beautiful theory by a gang of ugly facts.

