#### Your Code as a Crime Scene, Second Edition (Tornhill, Adam)
      Software is a socio-technical construct, where team dynamics, deadlines, personal preferences, skills, and organizational values leave their mark on a codebase and its history.

      In a surprisingly short time, we’ve moved from lighting fires in our caves to reasoning about multicores and CPU caches in cubicles. Yet, we handle modern technology with the same biological tools our prehistoric ancestors used for basic survival. That’s why taming complexity in software must start with how we think. Programming needs to be aligned with the way our brain works.

      Building software at scale might be the most challenging task humanity ever attempted. Accidental complexity—code that is more complicated than the problem calls for—adds to the challenge. Such code becomes expensive to maintain, bug-ridden, and hard to change.

      Complex code is only a problem if we need to deal with it. Maybe our most complex piece of code has been stable for years, works wonderfully in production, and no one needs to modify it. Does it really make a difference whether it’s complex? Well, you may have a potential time bomb waiting to go off, and it’s a long-term risk you need to be aware of. But large-scale codebases are full of unwarranted complexity. It’s unreasonable to address them all at once.

      This limitation isn’t specific to cyclomatic complexity but is a fundamental property of code metrics in general. No matter how accurate our metrics are—and there are better options than cyclomatic complexity out there—if we limit ourselves to a static view of the code, then we will never be able to prioritize the parts that really matter.

