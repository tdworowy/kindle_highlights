#### Linux Kernel Programming: A comprehensive and practical guide to kernel internals, writing modules, and kernel synchronization (Billimoria, Kaiwan N.)
      User space and kernel space Modern microprocessors support code execution at a minimum of two privilege levels. As a real-world example, the Intel/AMD x86[-64] family supports four privilege levels (they call them ring levels), the AArch32 (ARM-32) microprocessor family supports up to seven modes (ARM calls them execution modes; six are privileged and one is non-privileged), and the AArch64 (ARM-64/ARMv8) microprocessor family supports four exception levels (EL0 to EL3, with EL0 being the least and EL3 being the most privileged).

      Fear not; here’s a site with all the challenges (and solutions, but don’t cheat!) posted. Do check it out and try the challenges. This will greatly accelerate your kernel hacking skills: https://github.com/agelastic/eudyptula.

      It’s also critical to understand that most modern OS are monolithic in design. The word monolithic literally means a single large piece of stone. We shall defer a little later to how exactly this applies to our favorite OS! For now, just understand monolithic as meaning this: when a process or thread issues a system call, it switches to (privileged) kernel mode, executes kernel code, and possibly works on kernel data. Yes, there is no kernel or kernel thread executing code on its behalf; the process (or thread) issuing the system call is switched to kernel mode and itself executes kernel code.

      Well, you may ask, now that I understand this, how else – besides process context – can kernel code execute? There is another way: when a hardware interrupt (from a peripheral device – the keyboard, a network card, a disk, and so on) fires, the CPU’s control unit saves the current context and immediately re-vectors the CPU to run the code of the interrupt handler (the interrupt service routine (ISR)). Now, this code runs in kernel (privileged) mode too – in effect, this is another, asynchronous, way to switch to kernel mode (unless you were already there)!

      Just FYI, the microkernel architecture is perhaps the diametrically opposite approach to monolithic ones. It’s approach is a message-passing one (no system calls), where messages are passed from the user app/process to server processes, which perform the work. They, in turn, and as required, talk to the small microkernel, again via messages. Done well, it also offers excellent performance; apparently, though, it’s hard to design and implement a micro-kernel-based OS well (think of GNU Hurd). Of course, they very much exist: QNX, VxWorks, and ENEA are excellent real-world (and hard real-time) examples of a microkernel OS done well, while Tannenbaum’s Minix is a (mostly) classroom microkernel.

      Next, as is often thought, a virtual address is not an absolute value (an offset from 0); it’s a bitmask that’s designed for and interpreted by the MMU (the Memory Management Unit that’s within the silicon of modern microprocessors):

      all processes alive on the system have their own unique user-mode VAS but share the same kernel VAS.

