#### We, Programmers (Robert C. Martin Series) (Martin, Robert)
      Despite their best efforts to eliminate the need for programmers, that need has only increased and diversified. And now, they think the solution will be AI. But, trust me, the outcome will be the same. With greater power, the need for and stature of programmers can only increase.
      We love details. We revel in details. We swim upstream in rivers of details. We slog through marshes and swamplands of details. And we love it. We live for it. We work joyously hard at it. We are . . . detail managers.
      Once you understand how a difference engine works, it’s not too hard to set up surprises like that. After all, the sequence 0, 2, 4, 6, 8, 10, 42 has a set of differences that, when added forward, will reproduce that sequence. Babbage then told his guests that the machine was obeying hidden laws that he alone knew. He would go on to tell them that the “miracle” of the 42 was similar to miracles such as the parting of the Red Sea or the healing of the sick. God, you see, is a programmer who built the universe with hidden laws that only He knew.10
      Babbage was an inventor, a tinkerer, a visionary, and . . . a programmer. Unfortunately, like many of us, he allowed the perfect to be the enemy of the good. Like many of us, he was overconfident in his designs and gave little or no thought to incrementalism. Like many of us, he was easily enthralled by an idea, and was happy to think that idea 80% of the way through, but did not maintain that enthusiasm when it came to the last 20%, which requires 80% of the effort.
      The man who came up with the computer architecture combining instructions and data was Alan Turing; but it was the influence of John von Neumann that drove the adoption of that architecture.
      there are true statements in mathematics that cannot be proven by mathematics—mathematics is incomplete.
      As bad as that period was, the rebound was worse. The communists had been largely Jewish, so antisemitic horror raged, and thousands of Jews were killed, and more were raped and tortured.14 Fortunately, John survived this rampage, too.
      His frightened wife, Klári,25 recalls his words this way:26 25. Klára Dán von Neumann (1911–1963). 26. Bhattacharya, p. 102. “What we are creating now is a monster whose influence is going to change history, provided there is any history left, yet it would be impossible not to see it through, not only for the military reasons, but it would also be unethical from the point of view of the scientists not to do what they know is feasible, no matter what terrible consequences it may have. And this is only the beginning! The energy source which is now being made available will make scientists the most hated and also the most wanted citizens of any country.”
      That better way, which she called automatic programming, involved having a computer program determine the numeric instructions from a more abstract language that was more comfortable for the programmer. She wrote the first such program and called it a compiler.
      So she ran a timing comparison between one programmer using A-0 and a team of experienced programmers just writing raw C-10 code. The problem was to produce a table of results for the simple mathematical function y=exp(-x)*sin(x/2). Using raw C-10 required three programmers working for a little over 14.5 hours (∽44 man-hours). Using A-0, a single programmer got the job done in 48.5 minutes. That’s a factor of over 50!
      Alan Kay once affectionately said of him: “Arrogance in computer science is measured in nano-Dijkstras.”
      Mathematics is a positive discipline—we prove things correct using formal logic. Software, as it turns out, is a negative discipline—we prove things incorrect by observation. If that sounds familiar, it should. Software is a science.
      Testing was something that Dijkstra complained about by saying: “Testing shows the presence, not the absence, of bugs.” And, of course, he was correct. What he missed, in my opinion, is that his statement proved that software is not mathematics, but rather a science.
      Now, let’s go back over this. Kemeny, Kurtz, and a gaggle of geeky undergrads wrote a front-end terminal management system that communicated with a back-end time-sharing system and a compiler, from scratch, in assembly language, on two primitive and quirky GE computers, in less than one year; and they only had access to the machine for the last three months of that year.
      It turns out that in order to make a reusable framework, you need to actually use it in more than one application. Who knew?
      In the meantime, the Agile movement had gone off the rails. What had started as a movement driven by programmers had changed to a movement driven by project managers. Programmers were gradually, but very effectively, pushed out of the movement.
      When you mix a little4 bit of neural networking, a nice little Markov chain algorithm, the contents of the Library of Congress, every page on the Web, and all the research papers in every university library, you can get some pretty surprising results. 4. By some definition of “little.” Surprising, but not necessarily very intelligent.
      Remember that the original programmers who coded in binary were very afraid that Grace Hopper’s A0 compiler, as horribly primitive as it was, was going to replace them. And, in fact, the opposite happened. As the tooling got better, the higher the demand grew for more and more programmers. Why? Why does the demand for programmers seem to grow without bound? Why does the number of programmers in the world double every five years? The answer is, simply, that we have by no means exhausted the uses to which computers can be put. The number of potential applications is vastly greater than the number of existing applications.
      My best guess about what programming will be like 50 years from now is to look at what programming was like 50 years ago. Fifty years ago, in 1973, I was writing if statements, while loops, and assignment statements into text files and then compiling and testing them. Today I write if statements, while loops, and assignment statements into text files and then compile and test them. Therefore, I can only assume that 50 years from now, if I live to be 120 and am still programming, I will be writing if statements, while loops, and assignment statements and compiling and testing them.
